import javax.xml.crypto.dsig.spec.XSLTTransformParameterSpec;
import java.util.*;
import java.io.BufferedWriter;
import java.io.BufferedReader;
import java.io.FileWriter;
import java.io.FileReader;
import java.io.IOException;
import java.io.File;

class CuckooFilter {
    private int bucketSize = 1;
    private int numBucket = 1;
    private static final int MAX_KICKS = 500;
    private int[][] buckets;    //stores the fingerprint of tuples
    private int[] slots;    //how many slots within a bucket is occupied
    private int kickOuts;

    public CuckooFilter(int bucketSize, int numBucket){
        this.bucketSize = bucketSize;
        this.numBucket = numBucket;
        this.kickOuts = 0;
        this.buckets = new int[numBucket][bucketSize];
        this.slots = new int[numBucket];
        for(int i = 0; i < numBucket; i++){
            slots[i] = 0;
        }
    }

    private int fingerprint(String key){
        int code = key.hashCode();
        return code;
    }

    private int hash(String key){
        int code = 0;
        for(int i = 0; i < key.length(); i++){
            code += (key.charAt(i) * Math.pow(127, i)) % 1000199;
        }
        return code % this.numBucket;
    }
    public boolean insert(String key){

        int fp = this.fingerprint(key);
        int index1 = this.hash(key);
        int index2 = (index1 ^ hash(""+fp)) % this.numBucket;
        if(slots[index1] < this.bucketSize){
            buckets[index1][slots[index1]] = fp;
            slots[index1] ++;
            return true;    // successfully inserted
        }
        else if(slots[index2] < this.bucketSize){
            buckets[index2][slots[index2]] = fp;
            slots[index2] ++;
            return true;    // successfully inserted
        }
        else{
            Random random = new Random();
            boolean hashFuncSelector = random.nextBoolean();
            int kickIndex = hashFuncSelector ? index2 : index1;     //randomly pick index1 or index2
            System.out.println("Start kicking!");
            for(int i = 0; i < MAX_KICKS; i++){
                this.kickOuts ++;
                int randomIdx = random.nextInt(this.slots[kickIndex]);
                int temp = buckets[kickIndex][randomIdx];
                buckets[kickIndex][randomIdx] = fp;
                fp = temp;
                System.out.println("Kick out fingerprint" + fp);
                kickIndex ^= hash(""+fp);
                kickIndex = kickIndex % numBucket;
                if(slots[kickIndex] < this.bucketSize){
                    buckets[kickIndex][slots[kickIndex]] = fp;
                    slots[kickIndex] ++;
                    return true;
                }
            }
        }
        return false;
    }

    public int[] lookup(String key){
        int fp = fingerprint(key);
        int index1 = this.hash(key);
        int index2 = (index1 ^ this.fingerprint(""+fp)) % this.numBucket;
        int[] pos = {-1, -1};
        for(int i = 0; i < this.slots[index1]; i++){
            if(this.buckets[index1][i] == fp){
                pos[0] = index1;
                pos[1] = i;
            }
        }
        for(int i = 0; i < this.slots[index2]; i++){
            if(this.buckets[index2][i] == fp){
                pos[0] = index2;
                pos[1] = i;
            }
        }
        return pos;
    }

    public boolean delete(String key){
        int[] pos = this.lookup(key);
        if(pos[0] <= 0) return false;
        for(int i = pos[1]; i < this.bucketSize - 1; i++){
            this.buckets[pos[0]][i] = this.buckets[pos[0]][i+1];
        }
        this.buckets[pos[0]][this.bucketSize - 1] = 0;
        this.slots[pos[0]]--;
        return true;
    }

    public int getKickOuts(){
        return this.kickOuts;
    }

    public void clear(){
        this.buckets = new int[numBucket][bucketSize];
        this.slots = new int[numBucket];
        for(int i = 0; i < numBucket; i++){
            slots[i] = 0;
        }
    }

    public void restructure(int bucketSize, int numBucket){
        this.bucketSize = bucketSize;
        this.numBucket = numBucket;
        this.kickOuts = 0;
        this.buckets = new int[numBucket][bucketSize];
        this.slots = new int[numBucket];
        for(int i = 0; i < numBucket; i++){
            slots[i] = 0;
        }
    }

}

public class Evaluator{

    private ArrayList<String> realEntries;
    private int negative;
    private int falsePositive;
    private int positive;
    public double timeCounter;

    public Evaluator(){
        this.negative = this.falsePositive = this.positive = 0;
        this.timeCounter = 0.0;
        this.realEntries = new ArrayList<>();
    }

    public boolean autoGenerateData(int numEntry, String fileName){
        Random random = new Random();

        try (BufferedWriter writer = new BufferedWriter(new FileWriter(fileName))) {
            for(int i = 0; i < numEntry; i++) {
                String randomString = "";
                for (int j = 0; j < 3; j++) {
                    randomString += (char) (random.nextInt(26) + 97);
                }
                writer.write(randomString);
                writer.newLine();
            }
        } catch (IOException e){
            e.printStackTrace();
        }
        return true;
    }

    public boolean autoLoadData(String fileName){
        try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {
            String line;
            while ((line = reader.readLine()) != null) {
                this.realEntries.add(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return true;
    }

    public boolean evaluate(CuckooFilter cuckooFilter, String fileName, int numEvaluation){
        cuckooFilter.clear();
        double startTime = System.nanoTime();
        for(String entry : realEntries){
            if(cuckooFilter.insert(entry) == false) return false;
        }
        double endTime = System.nanoTime();
        ArrayList<String> testEntries = new ArrayList<>();
        Random random = new Random();
        for(int i = 0; i < numEvaluation; i++){
            String randomString = "";
            for (int j = 0; j < 3; j++) {
                randomString += (char) (random.nextInt(26) + 97);
            }
            testEntries.add(randomString);
            int index = this.realEntries.indexOf(randomString);
            int[] pos = cuckooFilter.lookup(randomString);
            if(index < 0 && pos[0] < 0){
                this.negative ++;
            }
            else if(index < 0 && pos[0] > 0){
                this.falsePositive ++;
            }
            else{
                this.positive ++;
            }
        }
        this.timeCounter = endTime - startTime;
        System.out.println("Time consumption: "+ (endTime-startTime)/1000000 + " ms");

        try (BufferedWriter writer = new BufferedWriter(new FileWriter(fileName))) {
            for(String testEntry : testEntries){
                writer.write(testEntry);
                writer.write(" ");
            }
            writer.newLine();
            writer.write("Total kick-outs: " + cuckooFilter.getKickOuts());
            writer.newLine();
            writer.write("Total insertion time: " + this.timeCounter);
            writer.newLine();
            writer.write("Positive entries: " + this.positive);
            writer.newLine();
            writer.write("False positive entries: " + this.falsePositive);
            writer.newLine();
            writer.write("Negative entries: " + this.negative);
            writer.newLine();
            double TPR = ((double)this.positive) / ((double)(this.positive + this.falsePositive));
            double FPR = 1 - TPR;
            writer.write("True Positive Rate (TPR): " + TPR);
            writer.newLine();
            writer.write("False Positive Rate (TPR): " + FPR);
            writer.newLine();

        } catch (IOException e) {
            e.printStackTrace();
        }
        return true;
    }

    public static void main(String[] args) {
        System.out.println("Welcome to my Cuckoo Filter! Please input your configurations to initialize it.");
        System.out.print("Bucket Size:");
        Scanner scanner = new Scanner(System.in);
        int bucketSize = scanner.nextInt();
        System.out.print("Number of Buckets:");
        int numBucket = scanner.nextInt();
        CuckooFilter cuckooFilter = new CuckooFilter(bucketSize, numBucket);
        Evaluator evaluator = new Evaluator();
        while(true){
            System.out.println("Please choose an operation(1: insert, 2: lookup, 3: delete, 4: generate data file, 5: evaluate, 6: clear, 7: restructure, 0: exit)");
            int op = scanner.nextInt();
            scanner.nextLine();
            String key;
            String fileName;
            int numEntries = 5000;
            String numEntriesInput;
            String confirmAnswer;

            switch(op){
                case 1:    //insert
                    System.out.println("Please enter the key you want to insert:");
                    key = scanner.nextLine();
                    if(cuckooFilter.insert(key) == true){
                        System.out.println("Successfully inserted [" + key + "]");
                    }
                    else{
                        System.out.println("Failed to insert [" + key + "]: bucket full!");
                    }
                    break;
                case 2:
                    System.out.println("Please enter the key you want to look up:");
                    key = scanner.nextLine();
                    int[] pos = cuckooFilter.lookup(key);
                    if(pos[0] >= 0){
                        System.out.println("Key [" + key + "] exists at bucket No. " + pos[0]);
                    }
                    else{
                        System.out.println("Key [" + key + "] doest NOT exist!");
                    }
                    break;

                case 3:
                    System.out.println("Please enter the key you want to delete:");
                    key = scanner.nextLine();
                    if(cuckooFilter.delete(key) == true){
                        System.out.println("Successfully deleted [" + key + "]");
                    }
                    else{
                        System.out.println("Failed to delete [" + key + "]: bucket full!");
                    }
                    break;
                case 4:
                    System.out.println("Please enter the file name to store the data");
                    fileName = scanner.nextLine();
                    System.out.println("Please enter the numbers of entries (default: 5000)");

                    numEntriesInput = scanner.nextLine();
                    if(numEntriesInput.trim().isEmpty() == false){
                        try{
                            numEntries = Integer.parseInt(numEntriesInput);
                        } catch (NumberFormatException e){
                            System.out.println("Invalid input! The numbers of entries will be set at default");
                            numEntries = 5000;
                        }
                    }

                    evaluator.autoGenerateData(numEntries, fileName);
                    System.out.println("Successfully generated data");
                    break;
                case 5:
                    System.out.println("Please enter the file name of data");
                    fileName = scanner.nextLine();
                    evaluator.autoLoadData(fileName);
                    System.out.println("Please enter the file name to save the result");
                    fileName = scanner.nextLine();
                    numEntries = 5000;
                    System.out.println("Please enter the numbers of entries to evaluate");
                    numEntriesInput = scanner.nextLine();
                    if(numEntriesInput.trim().isEmpty() == false){
                        try{
                            numEntries = Integer.parseInt(numEntriesInput);
                        } catch (NumberFormatException e){
                            System.out.println("Invalid input! The numbers of entries will be set at default");
                            numEntries = 5000;
                        }
                    }
                    if(evaluator.evaluate(cuckooFilter, fileName, numEntries) == true){
                        System.out.println("Evaluation done, please check \""+ fileName +"\" for results.");
                    }
                    else {
                        System.out.println("Bucket full!");
                    }
                    break;

                case 6:
                    System.out.println("Do you want to clear all entries in the filter?[y/n]");
                    confirmAnswer = scanner.nextLine();
                    if(confirmAnswer.equals("y")){
                        cuckooFilter.clear();
                        System.out.println("Successfully cleared filter");
                    }
                    break;
                case 7:
                    System.out.println("Do you want to restructure the filter? Entries in the filter will be removed.[y/n]");
                    confirmAnswer = scanner.nextLine();
                    if(confirmAnswer.equals("y")){
                        cuckooFilter.clear();
                        System.out.println("Please input your configurations.");
                        System.out.print("Bucket Size:");
                        bucketSize = scanner.nextInt();
                        System.out.print("Number of Buckets:");
                        numBucket = scanner.nextInt();
                        cuckooFilter.restructure(bucketSize, numBucket);
                        System.out.println("Successfully restructured filter");
                    }
                    break;
                case 0:
                    System.out.println("Thanks for using!");
                    return;

                default:
                    break;
            }
        }
    }
}
